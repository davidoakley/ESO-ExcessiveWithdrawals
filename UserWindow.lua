---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by david.
--- DateTime: 03/05/2025 14:47
---

local Window = ExcessiveWithdrawals.window
local UserWindow = ExcessiveWithdrawals.userWindow
local fmtnum = ExcessiveWithdrawals.fmtnum
local GetColorDefForValue = ExcessiveWithdrawals.GetColorDefForValue

UserWindow.users = nil
UserWindow.processing = false

function UserWindow:Init()
	ZO_ScrollList_AddDataType(self.listCtrl, 0, "EWUserWindow_Row", 35, function(...) self:LayoutRow(...) end, nil, nil, nil)
end

function UserWindow:Open(guildId, userName)
	self.userName = userName
	self.guildId = guildId
	self:SetHidden(false)
	self:BringWindowToTop()
	self.titleLabel:SetText(GetGuildName(guildId) .. " - " .. userName)

	self:UpdateData()
	if not self.users then
		self:FetchTransactions()
	end
end

function UserWindow:Close()
	self:SetHidden(true)
end

local function eventTimeComparison(x,y)
	return x.eventTime > y.eventTime
end

function UserWindow:UpdateData()
	if not self.users or not self.users[self.userName].transactions then
		return
	end
	local transactions = self.users[self.userName].transactions
	table.sort(transactions, eventTimeComparison)
	self:ProcessBalances(transactions)

	ZO_ScrollList_Clear(self.listCtrl)
	local scrollData = ZO_ScrollList_GetDataList(self.listCtrl)

	d("Showing "..#transactions.." transactions")
	for i = 1, #transactions do
		local entry = ZO_ScrollList_CreateDataEntry(0, transactions[i])
		table.insert(scrollData, entry)
	end

	ZO_ScrollList_Commit(self.listCtrl)
end

function UserWindow:LayoutRow(rowCtrl, data, _)
	rowCtrl.nameLabel:SetText(data.name or "-")
	rowCtrl.dateLabel:SetText(os.date('%Y-%m-%d %H:%M:%S',data.eventTime) or "-")
	rowCtrl.priceLabel:SetText(fmtnum(data.price, true) or "-")
	rowCtrl.balanceLabel:SetText(fmtnum(data.balance, true) or "-")

	rowCtrl.nameLabel:SetWrapMode(TEXT_WRAP_MODE_ELLIPSIS)

	--local colour = data.member and ZO_DEFAULT_ENABLED_COLOR or ZO_DEFAULT_DISABLED_COLOR
	rowCtrl.priceLabel:SetColor(GetColorDefForValue(data.price):UnpackRGBA())
	rowCtrl.balanceLabel:SetColor(GetColorDefForValue(data.balance):UnpackRGBA())
end

function UserWindow:ProcessEvent(event)
	local info = event:GetEventInfo()
	local user = "@"..info.displayName
	local eventTime = event:GetEventTimestampS()
	if not self.users[user] then self.users[user] = { userName = user, transactions = {}, balance = 0 } end
	local userObj = self.users[user]

	if event:GetEventCategory() == GUILD_HISTORY_EVENT_CATEGORY_BANKED_CURRENCY then
		self:ProcessCashEvent(userObj, event, eventTime, info)
	else
		self:ProcessItemEvent(userObj, event, eventTime, info)
	end
	if user == self.userName then
		self:UpdateData()
	end
end


function UserWindow:ProcessItemEvent(userObj, event, eventTime, info)
	--local category = event:GetEventCategory()
	local type = event:GetEventType()
	local qty = info.quantity

	if qty < 0 then qty = qty * -1 end
	local price = (info.quantity ~= 0) and ExcessiveWithdrawals:GetPrice(info.itemLink) * qty or 0

	if type == GUILD_HISTORY_BANKED_ITEM_EVENT_ADDED then
		userObj.balance = userObj.balance + price
		table.insert(userObj.transactions, {
			eventTime = eventTime,
			name = "|cAAFFAAAdded " .. qty .. " x|r " .. info.itemLink,
			price = price,
			--balance = userObj.balance
		})
		--userObj.itemsDeposit = userObj.itemsDeposit + qty
		--userObj.itemsDepositVal = userObj.itemsDepositVal + price
		if ExcessiveWithdrawals.db.logging then d(string.format("%s - %s: +%d %s (worth %d)", ExcessiveWithdrawals.displayName, userObj.userName, qty, info.itemLink, price)) end
	elseif type == GUILD_HISTORY_BANKED_ITEM_EVENT_REMOVED then
		userObj.balance = userObj.balance - price
		table.insert(userObj.transactions, {
			eventTime = eventTime,
			name = "|cFFCC99Removed " .. qty .. " x|r " .. info.itemLink,
			price = -price,
			--balance = userObj.balance
		})
		--userObj.itemsWithdraw = userObj.itemsWithdraw + qty
		--userObj.itemsWithdrawVal = userObj.itemsWithdrawVal + price
		if ExcessiveWithdrawals.db.logging then d(string.format("%s - %s: -%d %s (worth %d)", ExcessiveWithdrawals.displayName, userObj.userName, qty, info.itemLink, price)) end
	end
end

function UserWindow:ProcessCashEvent(userObj, event, eventTime, info)
	local type = event:GetEventType()
	local amount = info.amount

	if amount then
		if type == GUILD_HISTORY_BANKED_CURRENCY_EVENT_DEPOSITED then
			userObj.balance = userObj.balance + amount
			table.insert(userObj.transactions, {
				eventTime = eventTime,
				name = "|cAAFFAACash Donation|r",
				price = amount,
				--balance = userObj.balance
			})
			--userObj.goldDeposit = userObj.goldDeposit + amount
			if ExcessiveWithdrawals.db.logging then d(string.format("%s - %s: +%d gold", ExcessiveWithdrawals.displayName, userObj.userName, amount)) end
		elseif type == GUILD_HISTORY_BANKED_CURRENCY_EVENT_WITHDRAWN then
			userObj.balance = userObj.balance - amount
			table.insert(userObj.transactions, {
				eventTime = eventTime,
				name = "|cFFCC99Cash Withdrawal|r",
				price = -amount,
				--balance = userObj.balance
			})
			--userObj.goldWithdraw = userObj.goldWithdraw + amount
			if ExcessiveWithdrawals.db.logging then d(string.format("%s - %s: -%d gold", ExcessiveWithdrawals.displayName, userObj.userName, amount)) end
		end
	else
		d("Stored event for nil amount event")
		ExcessiveWithdrawals.event = event
	end
end

local function processItems(self, lib, guildId, eventCategory)
	d("process")
	local processor = lib:CreateGuildHistoryProcessor(guildId, eventCategory, "ExcessiveWithdrawals_UserWindow")
	if not processor then
		-- the processor could not be created
		return
	end

	processor:SetStopOnLastCachedEvent(true)
	processor:SetOnStopCallback(function (reason)
		d("UserWindow.processing("..eventCategory..") stopped: " .. reason)
		UserWindow.processing = false
		UserWindow.spinner:SetHidden(true)
	end)

	--local now = GetTimeStamp()

	local started = processor:StartStreaming(nil, function(event)
		self:ProcessEvent(event)
	end)

	if not started then
		d("Failed to start processor for category "..eventCategory)
		self.processing = false
		self.spinner:SetHidden(true)
	end
end

function UserWindow:FetchTransactions()
	self.users = {}
	self.processing = true
	self.spinner:SetHidden(false)

	LibHistoire:OnReady(function(lib)
		processItems(self, lib, self.guildId, GUILD_HISTORY_EVENT_CATEGORY_BANKED_ITEM)
		processItems(self, lib, self.guildId, GUILD_HISTORY_EVENT_CATEGORY_BANKED_CURRENCY)
	end)
end

function UserWindow:ProcessBalances(sortedTransactions)
	local balance = 0
	for i = #sortedTransactions, 1, -1 do
		balance = balance + sortedTransactions[i].price
		sortedTransactions[i].balance = balance
	end
end